<?php
namespace cassandra;
/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface CassandraIf {
  /**
   * @param AuthenticationRequest $auth_request
   * @throws AuthenticationException
   * @throws AuthorizationException
   */
  public function login(AuthenticationRequest $auth_request);
  /**
   * @param string $keyspace
   * @throws InvalidRequestException
   */
  public function set_keyspace($keyspace);
  /**
   * Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
   * the only method that can throw an exception under non-failure conditions.)
   * 
   * @param string $key
   * @param ColumnPath $column_path
   * @param int $consistency_level
   * @return ColumnOrSuperColumn Methods for fetching rows/records from Cassandra will return either a single instance of ColumnOrSuperColumn or a list
   * of ColumnOrSuperColumns (get_slice()). If you're looking up a SuperColumn (or list of SuperColumns) then the resulting
   * instances of ColumnOrSuperColumn will have the requested SuperColumn in the attribute super_column. For queries resulting
   * in Columns, those values will be in the attribute column. This change was made between 0.3 and 0.4 to standardize on
   * single query methods that may return either a SuperColumn or Column.
   * 
   * If the query was on a counter column family, you will either get a counter_column (instead of a column) or a
   * counter_super_column (instead of a super_column)
   * 
   * @param column. The Column returned by get() or get_slice().
   * @param super_column. The SuperColumn returned by get() or get_slice().
   * @param counter_column. The Counterolumn returned by get() or get_slice().
   * @param counter_super_column. The CounterSuperColumn returned by get() or get_slice().
   * 
   * @throws InvalidRequestException
   * @throws NotFoundException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function get($key, ColumnPath $column_path, $consistency_level);
  /**
   * Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
   * pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
   * 
   * @param string $key
   * @param ColumnParent $column_parent
   * @param SlicePredicate $predicate
   * @param int $consistency_level
   * @return ColumnOrSuperColumn[]
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function get_slice($key, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level);
  /**
   * returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
   * <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
   * 
   * @param string $key
   * @param ColumnParent $column_parent
   * @param SlicePredicate $predicate
   * @param int $consistency_level
   * @return int
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function get_count($key, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level);
  /**
   * Performs a get_slice for column_parent and predicate for the given keys in parallel.
   * 
   * @param string[] $keys
   * @param ColumnParent $column_parent
   * @param SlicePredicate $predicate
   * @param int $consistency_level
   * @return array
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function multiget_slice(array $keys, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level);
  /**
   * Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
   * 
   * @param string[] $keys
   * @param ColumnParent $column_parent
   * @param SlicePredicate $predicate
   * @param int $consistency_level
   * @return array
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function multiget_count(array $keys, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level);
  /**
   * returns a subset of columns for a contiguous range of keys.
   * 
   * @param ColumnParent $column_parent
   * @param SlicePredicate $predicate
   * @param KeyRange $range
   * @param int $consistency_level
   * @return KeySlice[]
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function get_range_slices(ColumnParent $column_parent, SlicePredicate $predicate, KeyRange $range, $consistency_level);
  /**
   * returns a range of columns, wrapping to the next rows if necessary to collect max_results.
   * 
   * @param string $column_family
   * @param KeyRange $range
   * @param string $start_column
   * @param int $consistency_level
   * @return KeySlice[]
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function get_paged_slice($column_family, KeyRange $range, $start_column, $consistency_level);
  /**
   * Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
   * @deprecated use get_range_slices instead with range.row_filter specified
   * 
   * @param ColumnParent $column_parent
   * @param IndexClause $index_clause
   * @param SlicePredicate $column_predicate
   * @param int $consistency_level
   * @return KeySlice[]
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function get_indexed_slices(ColumnParent $column_parent, IndexClause $index_clause, SlicePredicate $column_predicate, $consistency_level);
  /**
   * Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
   * 
   * @param string $key
   * @param ColumnParent $column_parent
   * @param Column $column
   * @param int $consistency_level
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function insert($key, ColumnParent $column_parent, Column $column, $consistency_level);
  /**
   * Increment or decrement a counter.
   * 
   * @param string $key
   * @param ColumnParent $column_parent
   * @param CounterColumn $column
   * @param int $consistency_level
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function add($key, ColumnParent $column_parent, CounterColumn $column, $consistency_level);
  /**
   * Atomic compare and set.
   * 
   * If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
   * Otherwise, success will be false and current_values will contain the current values for the columns in
   * expected (that, by definition of compare-and-set, will differ from the values in expected).
   * 
   * A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
   * level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
   * The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
   * is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
   * the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
   * guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
   * commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
   * the write.
   * 
   * @param string $key
   * @param string $column_family
   * @param Column[] $expected
   * @param Column[] $updates
   * @param int $serial_consistency_level
   * @param int $commit_consistency_level
   * @return CASResult
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function cas($key, $column_family, array $expected, array $updates, $serial_consistency_level, $commit_consistency_level);
  /**
   * Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
   * that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
   * row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
   * 
   * @param string $key
   * @param ColumnPath $column_path
   * @param int $timestamp
   * @param int $consistency_level
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function remove($key, ColumnPath $column_path, $timestamp, $consistency_level);
  /**
   * Remove a counter at the specified location.
   * Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
   * until the delete has reached all the nodes and all of them have been fully compacted.
   * 
   * @param string $key
   * @param ColumnPath $path
   * @param int $consistency_level
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function remove_counter($key, ColumnPath $path, $consistency_level);
  /**
   *   Mutate many columns or super columns for many row keys. See also: Mutation.
   * 
   *   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
   * *
   * 
   * @param array $mutation_map
   * @param int $consistency_level
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function batch_mutate(array $mutation_map, $consistency_level);
  /**
   *   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
   * 
   *   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
   * *
   * 
   * @param array $mutation_map
   * @param int $consistency_level
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function atomic_batch_mutate(array $mutation_map, $consistency_level);
  /**
   * Truncate will mark and entire column family as deleted.
   * From the user's perspective a successful call to truncate will result complete data deletion from cfname.
   * Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
   * only marks the data as deleted.
   * The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
   * some hosts are down.
   * 
   * @param string $cfname
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function truncate($cfname);
  /**
   * Select multiple slices of a key in a single RPC operation
   * 
   * @param MultiSliceRequest $request
   * @return ColumnOrSuperColumn[]
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   */
  public function get_multi_slice(MultiSliceRequest $request);
  /**
   * for each schema version present in the cluster, returns a list of nodes at that version.
   * hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
   * the cluster is all on the same version if the size of the map is 1.
   * 
   * @return array
   * @throws InvalidRequestException
   */
  public function describe_schema_versions();
  /**
   * list the defined keyspaces in this cluster
   * 
   * @return KsDef[]
   * @throws InvalidRequestException
   */
  public function describe_keyspaces();
  /**
   * get the cluster name
   * 
   * @return string
   */
  public function describe_cluster_name();
  /**
   * get the thrift api version
   * 
   * @return string
   */
  public function describe_version();
  /**
   * get the token ring: a map of ranges to host addresses,
   * represented as a set of TokenRange instead of a map from range
   * to list of endpoints, because you can't use Thrift structs as
   * map keys:
   * https://issues.apache.org/jira/browse/THRIFT-162
   * 
   * for the same reason, we can't return a set here, even though
   * order is neither important nor predictable.
   * 
   * @param string $keyspace
   * @return TokenRange[]
   * @throws InvalidRequestException
   */
  public function describe_ring($keyspace);
  /**
   * same as describe_ring, but considers only nodes in the local DC
   * 
   * @param string $keyspace
   * @return TokenRange[]
   * @throws InvalidRequestException
   */
  public function describe_local_ring($keyspace);
  /**
   * get the mapping between token->node ip
   * without taking replication into consideration
   * https://issues.apache.org/jira/browse/CASSANDRA-4092
   * 
   * @return array
   * @throws InvalidRequestException
   */
  public function describe_token_map();
  /**
   * returns the partitioner used by this cluster
   * 
   * @return string
   */
  public function describe_partitioner();
  /**
   * returns the snitch used by this cluster
   * 
   * @return string
   */
  public function describe_snitch();
  /**
   * describe specified keyspace
   * 
   * @param string $keyspace
   * @return KsDef
   * @throws NotFoundException
   * @throws InvalidRequestException
   */
  public function describe_keyspace($keyspace);
  /**
   * experimental API for hadoop/parallel query support.
   * may change violently and without warning.
   * 
   * returns list of token strings such that first subrange is (list[0], list[1]],
   * next is (list[1], list[2]], etc.
   * 
   * @param string $cfName
   * @param string $start_token
   * @param string $end_token
   * @param int $keys_per_split
   * @return string[]
   * @throws InvalidRequestException
   */
  public function describe_splits($cfName, $start_token, $end_token, $keys_per_split);
  /**
   * Enables tracing for the next query in this connection and returns the UUID for that trace session
   * The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
   * 
   * @return string
   */
  public function trace_next_query();
  /**
   * @param string $cfName
   * @param string $start_token
   * @param string $end_token
   * @param int $keys_per_split
   * @return CfSplit[]
   * @throws InvalidRequestException
   */
  public function describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split);
  /**
   * adds a column family. returns the new schema id.
   * 
   * @param CfDef $cf_def
   * @return string
   * @throws InvalidRequestException
   * @throws SchemaDisagreementException
   */
  public function system_add_column_family(CfDef $cf_def);
  /**
   * drops a column family. returns the new schema id.
   * 
   * @param string $column_family
   * @return string
   * @throws InvalidRequestException
   * @throws SchemaDisagreementException
   */
  public function system_drop_column_family($column_family);
  /**
   * adds a keyspace and any column families that are part of it. returns the new schema id.
   * 
   * @param KsDef $ks_def
   * @return string
   * @throws InvalidRequestException
   * @throws SchemaDisagreementException
   */
  public function system_add_keyspace(KsDef $ks_def);
  /**
   * drops a keyspace and any column families that are part of it. returns the new schema id.
   * 
   * @param string $keyspace
   * @return string
   * @throws InvalidRequestException
   * @throws SchemaDisagreementException
   */
  public function system_drop_keyspace($keyspace);
  /**
   * updates properties of a keyspace. returns the new schema id.
   * 
   * @param KsDef $ks_def
   * @return string
   * @throws InvalidRequestException
   * @throws SchemaDisagreementException
   */
  public function system_update_keyspace(KsDef $ks_def);
  /**
   * updates properties of a column family. returns the new schema id.
   * 
   * @param CfDef $cf_def
   * @return string
   * @throws InvalidRequestException
   * @throws SchemaDisagreementException
   */
  public function system_update_column_family(CfDef $cf_def);
  /**
   * @deprecated Throws InvalidRequestException since 3.0. Please use the CQL3 version instead.
   * 
   * @param string $query
   * @param int $compression
   * @return CqlResult
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   * @throws SchemaDisagreementException
   */
  public function execute_cql_query($query, $compression);
  /**
   * Executes a CQL3 (Cassandra Query Language) statement and returns a
   * CqlResult containing the results.
   * 
   * @param string $query
   * @param int $compression
   * @param int $consistency
   * @return CqlResult
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   * @throws SchemaDisagreementException
   */
  public function execute_cql3_query($query, $compression, $consistency);
  /**
   * @deprecated Throws InvalidRequestException since 3.0. Please use the CQL3 version instead.
   * 
   * @param string $query
   * @param int $compression
   * @return CqlPreparedResult
   * @throws InvalidRequestException
   */
  public function prepare_cql_query($query, $compression);
  /**
   * Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
   * - the type of CQL statement
   * - an id token of the compiled CQL stored on the server side.
   * - a count of the discovered bound markers in the statement
   * 
   * @param string $query
   * @param int $compression
   * @return CqlPreparedResult
   * @throws InvalidRequestException
   */
  public function prepare_cql3_query($query, $compression);
  /**
   * @deprecated Throws InvalidRequestException since 3.0. Please use the CQL3 version instead.
   * 
   * @param int $itemId
   * @param string[] $values
   * @return CqlResult
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   * @throws SchemaDisagreementException
   */
  public function execute_prepared_cql_query($itemId, array $values);
  /**
   * Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
   * to bind, and the consistency level, and returns a CqlResult containing the results.
   * 
   * @param int $itemId
   * @param string[] $values
   * @param int $consistency
   * @return CqlResult
   * @throws InvalidRequestException
   * @throws UnavailableException
   * @throws TimedOutException
   * @throws SchemaDisagreementException
   */
  public function execute_prepared_cql3_query($itemId, array $values, $consistency);
  /**
   * @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
   * 
   * @param string $version
   * @throws InvalidRequestException
   */
  public function set_cql_version($version);
}

class CassandraClient implements CassandraIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function login(AuthenticationRequest $auth_request)
  {
    $this->send_login($auth_request);
    $this->recv_login();
  }

  public function send_login(AuthenticationRequest $auth_request)
  {
    $args = new Cassandra_login_args();
    $args->auth_request = $auth_request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'login', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('login', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_login()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_login_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_login_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->authnx !== null) {
      throw $result->authnx;
    }
    if ($result->authzx !== null) {
      throw $result->authzx;
    }
    return;
  }

  public function set_keyspace($keyspace)
  {
    $this->send_set_keyspace($keyspace);
    $this->recv_set_keyspace();
  }

  public function send_set_keyspace($keyspace)
  {
    $args = new Cassandra_set_keyspace_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'set_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('set_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_set_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_set_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_set_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    return;
  }

  public function get($key, ColumnPath $column_path, $consistency_level)
  {
    $this->send_get($key, $column_path, $consistency_level);
    return $this->recv_get();
  }

  public function send_get($key, ColumnPath $column_path, $consistency_level)
  {
    $args = new Cassandra_get_args();
    $args->key = $key;
    $args->column_path = $column_path;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_get_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->nfe !== null) {
      throw $result->nfe;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get failed: unknown result");
  }

  public function get_slice($key, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level)
  {
    $this->send_get_slice($key, $column_parent, $predicate, $consistency_level);
    return $this->recv_get_slice();
  }

  public function send_get_slice($key, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level)
  {
    $args = new Cassandra_get_slice_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_slice', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_slice()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_get_slice_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_slice failed: unknown result");
  }

  public function get_count($key, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level)
  {
    $this->send_get_count($key, $column_parent, $predicate, $consistency_level);
    return $this->recv_get_count();
  }

  public function send_get_count($key, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level)
  {
    $args = new Cassandra_get_count_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_count', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_count', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_count()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_count_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_get_count_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_count failed: unknown result");
  }

  public function multiget_slice(array $keys, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level)
  {
    $this->send_multiget_slice($keys, $column_parent, $predicate, $consistency_level);
    return $this->recv_multiget_slice();
  }

  public function send_multiget_slice(array $keys, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level)
  {
    $args = new Cassandra_multiget_slice_args();
    $args->keys = $keys;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'multiget_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('multiget_slice', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_multiget_slice()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_multiget_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_multiget_slice_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("multiget_slice failed: unknown result");
  }

  public function multiget_count(array $keys, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level)
  {
    $this->send_multiget_count($keys, $column_parent, $predicate, $consistency_level);
    return $this->recv_multiget_count();
  }

  public function send_multiget_count(array $keys, ColumnParent $column_parent, SlicePredicate $predicate, $consistency_level)
  {
    $args = new Cassandra_multiget_count_args();
    $args->keys = $keys;
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'multiget_count', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('multiget_count', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_multiget_count()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_multiget_count_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_multiget_count_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("multiget_count failed: unknown result");
  }

  public function get_range_slices(ColumnParent $column_parent, SlicePredicate $predicate, KeyRange $range, $consistency_level)
  {
    $this->send_get_range_slices($column_parent, $predicate, $range, $consistency_level);
    return $this->recv_get_range_slices();
  }

  public function send_get_range_slices(ColumnParent $column_parent, SlicePredicate $predicate, KeyRange $range, $consistency_level)
  {
    $args = new Cassandra_get_range_slices_args();
    $args->column_parent = $column_parent;
    $args->predicate = $predicate;
    $args->range = $range;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_range_slices', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_range_slices', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_range_slices()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_range_slices_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_get_range_slices_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_range_slices failed: unknown result");
  }

  public function get_paged_slice($column_family, KeyRange $range, $start_column, $consistency_level)
  {
    $this->send_get_paged_slice($column_family, $range, $start_column, $consistency_level);
    return $this->recv_get_paged_slice();
  }

  public function send_get_paged_slice($column_family, KeyRange $range, $start_column, $consistency_level)
  {
    $args = new Cassandra_get_paged_slice_args();
    $args->column_family = $column_family;
    $args->range = $range;
    $args->start_column = $start_column;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_paged_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_paged_slice', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_paged_slice()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_paged_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_get_paged_slice_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_paged_slice failed: unknown result");
  }

  public function get_indexed_slices(ColumnParent $column_parent, IndexClause $index_clause, SlicePredicate $column_predicate, $consistency_level)
  {
    $this->send_get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
    return $this->recv_get_indexed_slices();
  }

  public function send_get_indexed_slices(ColumnParent $column_parent, IndexClause $index_clause, SlicePredicate $column_predicate, $consistency_level)
  {
    $args = new Cassandra_get_indexed_slices_args();
    $args->column_parent = $column_parent;
    $args->index_clause = $index_clause;
    $args->column_predicate = $column_predicate;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_indexed_slices', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_indexed_slices', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_indexed_slices()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_indexed_slices_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_get_indexed_slices_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_indexed_slices failed: unknown result");
  }

  public function insert($key, ColumnParent $column_parent, Column $column, $consistency_level)
  {
    $this->send_insert($key, $column_parent, $column, $consistency_level);
    $this->recv_insert();
  }

  public function send_insert($key, ColumnParent $column_parent, Column $column, $consistency_level)
  {
    $args = new Cassandra_insert_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->column = $column;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'insert', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('insert', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_insert()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_insert_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_insert_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function add($key, ColumnParent $column_parent, CounterColumn $column, $consistency_level)
  {
    $this->send_add($key, $column_parent, $column, $consistency_level);
    $this->recv_add();
  }

  public function send_add($key, ColumnParent $column_parent, CounterColumn $column, $consistency_level)
  {
    $args = new Cassandra_add_args();
    $args->key = $key;
    $args->column_parent = $column_parent;
    $args->column = $column;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_add_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_add_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function cas($key, $column_family, array $expected, array $updates, $serial_consistency_level, $commit_consistency_level)
  {
    $this->send_cas($key, $column_family, $expected, $updates, $serial_consistency_level, $commit_consistency_level);
    return $this->recv_cas();
  }

  public function send_cas($key, $column_family, array $expected, array $updates, $serial_consistency_level, $commit_consistency_level)
  {
    $args = new Cassandra_cas_args();
    $args->key = $key;
    $args->column_family = $column_family;
    $args->expected = $expected;
    $args->updates = $updates;
    $args->serial_consistency_level = $serial_consistency_level;
    $args->commit_consistency_level = $commit_consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'cas', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('cas', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_cas()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_cas_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_cas_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("cas failed: unknown result");
  }

  public function remove($key, ColumnPath $column_path, $timestamp, $consistency_level)
  {
    $this->send_remove($key, $column_path, $timestamp, $consistency_level);
    $this->recv_remove();
  }

  public function send_remove($key, ColumnPath $column_path, $timestamp, $consistency_level)
  {
    $args = new Cassandra_remove_args();
    $args->key = $key;
    $args->column_path = $column_path;
    $args->timestamp = $timestamp;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'remove', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('remove', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_remove()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_remove_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_remove_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function remove_counter($key, ColumnPath $path, $consistency_level)
  {
    $this->send_remove_counter($key, $path, $consistency_level);
    $this->recv_remove_counter();
  }

  public function send_remove_counter($key, ColumnPath $path, $consistency_level)
  {
    $args = new Cassandra_remove_counter_args();
    $args->key = $key;
    $args->path = $path;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'remove_counter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('remove_counter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_remove_counter()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_remove_counter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_remove_counter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function batch_mutate(array $mutation_map, $consistency_level)
  {
    $this->send_batch_mutate($mutation_map, $consistency_level);
    $this->recv_batch_mutate();
  }

  public function send_batch_mutate(array $mutation_map, $consistency_level)
  {
    $args = new Cassandra_batch_mutate_args();
    $args->mutation_map = $mutation_map;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'batch_mutate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('batch_mutate', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_batch_mutate()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_batch_mutate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_batch_mutate_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function atomic_batch_mutate(array $mutation_map, $consistency_level)
  {
    $this->send_atomic_batch_mutate($mutation_map, $consistency_level);
    $this->recv_atomic_batch_mutate();
  }

  public function send_atomic_batch_mutate(array $mutation_map, $consistency_level)
  {
    $args = new Cassandra_atomic_batch_mutate_args();
    $args->mutation_map = $mutation_map;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'atomic_batch_mutate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('atomic_batch_mutate', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_atomic_batch_mutate()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_atomic_batch_mutate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_atomic_batch_mutate_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function truncate($cfname)
  {
    $this->send_truncate($cfname);
    $this->recv_truncate();
  }

  public function send_truncate($cfname)
  {
    $args = new Cassandra_truncate_args();
    $args->cfname = $cfname;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'truncate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('truncate', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_truncate()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_truncate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_truncate_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    return;
  }

  public function get_multi_slice(MultiSliceRequest $request)
  {
    $this->send_get_multi_slice($request);
    return $this->recv_get_multi_slice();
  }

  public function send_get_multi_slice(MultiSliceRequest $request)
  {
    $args = new Cassandra_get_multi_slice_args();
    $args->request = $request;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_multi_slice', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_multi_slice', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_multi_slice()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_get_multi_slice_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_get_multi_slice_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    throw new \Exception("get_multi_slice failed: unknown result");
  }

  public function describe_schema_versions()
  {
    $this->send_describe_schema_versions();
    return $this->recv_describe_schema_versions();
  }

  public function send_describe_schema_versions()
  {
    $args = new Cassandra_describe_schema_versions_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_schema_versions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_schema_versions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_schema_versions()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_schema_versions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_schema_versions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_schema_versions failed: unknown result");
  }

  public function describe_keyspaces()
  {
    $this->send_describe_keyspaces();
    return $this->recv_describe_keyspaces();
  }

  public function send_describe_keyspaces()
  {
    $args = new Cassandra_describe_keyspaces_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_keyspaces', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_keyspaces', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_keyspaces()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_keyspaces_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_keyspaces_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_keyspaces failed: unknown result");
  }

  public function describe_cluster_name()
  {
    $this->send_describe_cluster_name();
    return $this->recv_describe_cluster_name();
  }

  public function send_describe_cluster_name()
  {
    $args = new Cassandra_describe_cluster_name_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_cluster_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_cluster_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_cluster_name()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_cluster_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_cluster_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("describe_cluster_name failed: unknown result");
  }

  public function describe_version()
  {
    $this->send_describe_version();
    return $this->recv_describe_version();
  }

  public function send_describe_version()
  {
    $args = new Cassandra_describe_version_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_version', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_version', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_version()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_version_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_version_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("describe_version failed: unknown result");
  }

  public function describe_ring($keyspace)
  {
    $this->send_describe_ring($keyspace);
    return $this->recv_describe_ring();
  }

  public function send_describe_ring($keyspace)
  {
    $args = new Cassandra_describe_ring_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_ring', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_ring', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_ring()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_ring_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_ring_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_ring failed: unknown result");
  }

  public function describe_local_ring($keyspace)
  {
    $this->send_describe_local_ring($keyspace);
    return $this->recv_describe_local_ring();
  }

  public function send_describe_local_ring($keyspace)
  {
    $args = new Cassandra_describe_local_ring_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_local_ring', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_local_ring', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_local_ring()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_local_ring_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_local_ring_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_local_ring failed: unknown result");
  }

  public function describe_token_map()
  {
    $this->send_describe_token_map();
    return $this->recv_describe_token_map();
  }

  public function send_describe_token_map()
  {
    $args = new Cassandra_describe_token_map_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_token_map', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_token_map', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_token_map()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_token_map_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_token_map_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_token_map failed: unknown result");
  }

  public function describe_partitioner()
  {
    $this->send_describe_partitioner();
    return $this->recv_describe_partitioner();
  }

  public function send_describe_partitioner()
  {
    $args = new Cassandra_describe_partitioner_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_partitioner', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_partitioner', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_partitioner()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_partitioner_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_partitioner_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("describe_partitioner failed: unknown result");
  }

  public function describe_snitch()
  {
    $this->send_describe_snitch();
    return $this->recv_describe_snitch();
  }

  public function send_describe_snitch()
  {
    $args = new Cassandra_describe_snitch_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_snitch', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_snitch', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_snitch()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_snitch_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_snitch_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("describe_snitch failed: unknown result");
  }

  public function describe_keyspace($keyspace)
  {
    $this->send_describe_keyspace($keyspace);
    return $this->recv_describe_keyspace();
  }

  public function send_describe_keyspace($keyspace)
  {
    $args = new Cassandra_describe_keyspace_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->nfe !== null) {
      throw $result->nfe;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_keyspace failed: unknown result");
  }

  public function describe_splits($cfName, $start_token, $end_token, $keys_per_split)
  {
    $this->send_describe_splits($cfName, $start_token, $end_token, $keys_per_split);
    return $this->recv_describe_splits();
  }

  public function send_describe_splits($cfName, $start_token, $end_token, $keys_per_split)
  {
    $args = new Cassandra_describe_splits_args();
    $args->cfName = $cfName;
    $args->start_token = $start_token;
    $args->end_token = $end_token;
    $args->keys_per_split = $keys_per_split;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_splits', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_splits', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_splits()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_splits_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_splits_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_splits failed: unknown result");
  }

  public function trace_next_query()
  {
    $this->send_trace_next_query();
    return $this->recv_trace_next_query();
  }

  public function send_trace_next_query()
  {
    $args = new Cassandra_trace_next_query_args();
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'trace_next_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('trace_next_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_trace_next_query()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_trace_next_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_trace_next_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("trace_next_query failed: unknown result");
  }

  public function describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split)
  {
    $this->send_describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split);
    return $this->recv_describe_splits_ex();
  }

  public function send_describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split)
  {
    $args = new Cassandra_describe_splits_ex_args();
    $args->cfName = $cfName;
    $args->start_token = $start_token;
    $args->end_token = $end_token;
    $args->keys_per_split = $keys_per_split;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'describe_splits_ex', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('describe_splits_ex', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_describe_splits_ex()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_describe_splits_ex_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_describe_splits_ex_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("describe_splits_ex failed: unknown result");
  }

  public function system_add_column_family(CfDef $cf_def)
  {
    $this->send_system_add_column_family($cf_def);
    return $this->recv_system_add_column_family();
  }

  public function send_system_add_column_family(CfDef $cf_def)
  {
    $args = new Cassandra_system_add_column_family_args();
    $args->cf_def = $cf_def;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_add_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_add_column_family', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_add_column_family()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_add_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_system_add_column_family_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_add_column_family failed: unknown result");
  }

  public function system_drop_column_family($column_family)
  {
    $this->send_system_drop_column_family($column_family);
    return $this->recv_system_drop_column_family();
  }

  public function send_system_drop_column_family($column_family)
  {
    $args = new Cassandra_system_drop_column_family_args();
    $args->column_family = $column_family;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_drop_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_drop_column_family', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_drop_column_family()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_drop_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_system_drop_column_family_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_drop_column_family failed: unknown result");
  }

  public function system_add_keyspace(KsDef $ks_def)
  {
    $this->send_system_add_keyspace($ks_def);
    return $this->recv_system_add_keyspace();
  }

  public function send_system_add_keyspace(KsDef $ks_def)
  {
    $args = new Cassandra_system_add_keyspace_args();
    $args->ks_def = $ks_def;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_add_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_add_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_add_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_add_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_system_add_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_add_keyspace failed: unknown result");
  }

  public function system_drop_keyspace($keyspace)
  {
    $this->send_system_drop_keyspace($keyspace);
    return $this->recv_system_drop_keyspace();
  }

  public function send_system_drop_keyspace($keyspace)
  {
    $args = new Cassandra_system_drop_keyspace_args();
    $args->keyspace = $keyspace;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_drop_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_drop_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_drop_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_drop_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_system_drop_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_drop_keyspace failed: unknown result");
  }

  public function system_update_keyspace(KsDef $ks_def)
  {
    $this->send_system_update_keyspace($ks_def);
    return $this->recv_system_update_keyspace();
  }

  public function send_system_update_keyspace(KsDef $ks_def)
  {
    $args = new Cassandra_system_update_keyspace_args();
    $args->ks_def = $ks_def;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_update_keyspace', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_update_keyspace', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_update_keyspace()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_update_keyspace_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_system_update_keyspace_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_update_keyspace failed: unknown result");
  }

  public function system_update_column_family(CfDef $cf_def)
  {
    $this->send_system_update_column_family($cf_def);
    return $this->recv_system_update_column_family();
  }

  public function send_system_update_column_family(CfDef $cf_def)
  {
    $args = new Cassandra_system_update_column_family_args();
    $args->cf_def = $cf_def;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'system_update_column_family', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('system_update_column_family', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_system_update_column_family()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_system_update_column_family_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_system_update_column_family_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("system_update_column_family failed: unknown result");
  }

  public function execute_cql_query($query, $compression)
  {
    $this->send_execute_cql_query($query, $compression);
    return $this->recv_execute_cql_query();
  }

  public function send_execute_cql_query($query, $compression)
  {
    $args = new Cassandra_execute_cql_query_args();
    $args->query = $query;
    $args->compression = $compression;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_cql_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('execute_cql_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_execute_cql_query()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_execute_cql_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_execute_cql_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("execute_cql_query failed: unknown result");
  }

  public function execute_cql3_query($query, $compression, $consistency)
  {
    $this->send_execute_cql3_query($query, $compression, $consistency);
    return $this->recv_execute_cql3_query();
  }

  public function send_execute_cql3_query($query, $compression, $consistency)
  {
    $args = new Cassandra_execute_cql3_query_args();
    $args->query = $query;
    $args->compression = $compression;
    $args->consistency = $consistency;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_cql3_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('execute_cql3_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_execute_cql3_query()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_execute_cql3_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_execute_cql3_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("execute_cql3_query failed: unknown result");
  }

  public function prepare_cql_query($query, $compression)
  {
    $this->send_prepare_cql_query($query, $compression);
    return $this->recv_prepare_cql_query();
  }

  public function send_prepare_cql_query($query, $compression)
  {
    $args = new Cassandra_prepare_cql_query_args();
    $args->query = $query;
    $args->compression = $compression;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'prepare_cql_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('prepare_cql_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_prepare_cql_query()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_prepare_cql_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_prepare_cql_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("prepare_cql_query failed: unknown result");
  }

  public function prepare_cql3_query($query, $compression)
  {
    $this->send_prepare_cql3_query($query, $compression);
    return $this->recv_prepare_cql3_query();
  }

  public function send_prepare_cql3_query($query, $compression)
  {
    $args = new Cassandra_prepare_cql3_query_args();
    $args->query = $query;
    $args->compression = $compression;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'prepare_cql3_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('prepare_cql3_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_prepare_cql3_query()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_prepare_cql3_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_prepare_cql3_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    throw new \Exception("prepare_cql3_query failed: unknown result");
  }

  public function execute_prepared_cql_query($itemId, array $values)
  {
    $this->send_execute_prepared_cql_query($itemId, $values);
    return $this->recv_execute_prepared_cql_query();
  }

  public function send_execute_prepared_cql_query($itemId, array $values)
  {
    $args = new Cassandra_execute_prepared_cql_query_args();
    $args->itemId = $itemId;
    $args->values = $values;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_prepared_cql_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('execute_prepared_cql_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_execute_prepared_cql_query()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_execute_prepared_cql_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_execute_prepared_cql_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("execute_prepared_cql_query failed: unknown result");
  }

  public function execute_prepared_cql3_query($itemId, array $values, $consistency)
  {
    $this->send_execute_prepared_cql3_query($itemId, $values, $consistency);
    return $this->recv_execute_prepared_cql3_query();
  }

  public function send_execute_prepared_cql3_query($itemId, array $values, $consistency)
  {
    $args = new Cassandra_execute_prepared_cql3_query_args();
    $args->itemId = $itemId;
    $args->values = $values;
    $args->consistency = $consistency;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'execute_prepared_cql3_query', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('execute_prepared_cql3_query', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_execute_prepared_cql3_query()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_execute_prepared_cql3_query_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_execute_prepared_cql3_query_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    if ($result->ue !== null) {
      throw $result->ue;
    }
    if ($result->te !== null) {
      throw $result->te;
    }
    if ($result->sde !== null) {
      throw $result->sde;
    }
    throw new \Exception("execute_prepared_cql3_query failed: unknown result");
  }

  public function set_cql_version($version)
  {
    $this->send_set_cql_version($version);
    $this->recv_set_cql_version();
  }

  public function send_set_cql_version($version)
  {
    $args = new Cassandra_set_cql_version_args();
    $args->version = $version;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'set_cql_version', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('set_cql_version', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_set_cql_version()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\cassandra\Cassandra_set_cql_version_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Cassandra_set_cql_version_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->ire !== null) {
      throw $result->ire;
    }
    return;
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class Cassandra_login_args extends TBase {
  static $_TSPEC;

  /**
   * @var AuthenticationRequest
   */
  public $auth_request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'auth_request',
          'type' => TType::STRUCT,
          'class' => '\cassandra\AuthenticationRequest',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_login_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_login_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_login_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->auth_request === null) {
      throw new TProtocolException('Required field Cassandra_login_args.auth_request is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->auth_request === null) {
      throw new TProtocolException('Required field Cassandra_login_args.auth_request is unset!');
    }
  }

}

class Cassandra_login_result extends TBase {
  static $_TSPEC;

  /**
   * @var AuthenticationException
   */
  public $authnx = null;
  /**
   * @var AuthorizationException
   */
  public $authzx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'authnx',
          'type' => TType::STRUCT,
          'class' => '\cassandra\AuthenticationException',
          ),
        2 => array(
          'var' => 'authzx',
          'type' => TType::STRUCT,
          'class' => '\cassandra\AuthorizationException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_login_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_login_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_login_result', self::$_TSPEC, $output);
  }

}

class Cassandra_set_keyspace_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_set_keyspace_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_set_keyspace_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_set_keyspace_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_set_keyspace_args.keyspace is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_set_keyspace_args.keyspace is unset!');
    }
  }

}

class Cassandra_set_keyspace_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_set_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_set_keyspace_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_set_keyspace_result', self::$_TSPEC, $output);
  }

}

class Cassandra_get_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var ColumnPath
   */
  public $column_path = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_path',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnPath',
          ),
        3 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_get_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_get_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_get_args.key is unset!');
    }
    if ($this->column_path === null) {
      throw new TProtocolException('Required field Cassandra_get_args.column_path is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_get_args.key is unset!');
    }
    if ($this->column_path === null) {
      throw new TProtocolException('Required field Cassandra_get_args.column_path is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_args.consistency_level is unset!');
    }
  }

}

class Cassandra_get_result extends TBase {
  static $_TSPEC;

  /**
   * @var ColumnOrSuperColumn
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var NotFoundException
   */
  public $nfe = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnOrSuperColumn',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'nfe',
          'type' => TType::STRUCT,
          'class' => '\cassandra\NotFoundException',
          ),
        3 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        4 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_get_result', self::$_TSPEC, $output);
  }

}

class Cassandra_get_slice_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var ColumnParent
   */
  public $column_parent = null;
  /**
   * @var SlicePredicate
   */
  public $predicate = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_slice_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_get_slice_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_get_slice_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_get_slice_args.key is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_get_slice_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_get_slice_args.predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_slice_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_get_slice_args.key is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_get_slice_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_get_slice_args.predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_slice_args.consistency_level is unset!');
    }
  }

}

class Cassandra_get_slice_result extends TBase {
  static $_TSPEC;

  /**
   * @var ColumnOrSuperColumn[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\ColumnOrSuperColumn',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_slice_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_slice_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_get_slice_result', self::$_TSPEC, $output);
  }

}

class Cassandra_get_count_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var ColumnParent
   */
  public $column_parent = null;
  /**
   * @var SlicePredicate
   */
  public $predicate = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_count_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_get_count_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_get_count_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_get_count_args.key is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_get_count_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_get_count_args.predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_count_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_get_count_args.key is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_get_count_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_get_count_args.predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_count_args.consistency_level is unset!');
    }
  }

}

class Cassandra_get_count_result extends TBase {
  static $_TSPEC;

  /**
   * @var int
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_count_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_count_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_get_count_result', self::$_TSPEC, $output);
  }

}

class Cassandra_multiget_slice_args extends TBase {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $keys = null;
  /**
   * @var ColumnParent
   */
  public $column_parent = null;
  /**
   * @var SlicePredicate
   */
  public $predicate = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keys',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_multiget_slice_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_multiget_slice_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_multiget_slice_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->keys === null) {
      throw new TProtocolException('Required field Cassandra_multiget_slice_args.keys is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_multiget_slice_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_multiget_slice_args.predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_multiget_slice_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->keys === null) {
      throw new TProtocolException('Required field Cassandra_multiget_slice_args.keys is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_multiget_slice_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_multiget_slice_args.predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_multiget_slice_args.consistency_level is unset!');
    }
  }

}

class Cassandra_multiget_slice_result extends TBase {
  static $_TSPEC;

  /**
   * @var array
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\cassandra\ColumnOrSuperColumn',
              ),
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_multiget_slice_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_multiget_slice_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_multiget_slice_result', self::$_TSPEC, $output);
  }

}

class Cassandra_multiget_count_args extends TBase {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $keys = null;
  /**
   * @var ColumnParent
   */
  public $column_parent = null;
  /**
   * @var SlicePredicate
   */
  public $predicate = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keys',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_multiget_count_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_multiget_count_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_multiget_count_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->keys === null) {
      throw new TProtocolException('Required field Cassandra_multiget_count_args.keys is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_multiget_count_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_multiget_count_args.predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_multiget_count_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->keys === null) {
      throw new TProtocolException('Required field Cassandra_multiget_count_args.keys is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_multiget_count_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_multiget_count_args.predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_multiget_count_args.consistency_level is unset!');
    }
  }

}

class Cassandra_multiget_count_result extends TBase {
  static $_TSPEC;

  /**
   * @var array
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_multiget_count_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_multiget_count_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_multiget_count_result', self::$_TSPEC, $output);
  }

}

class Cassandra_get_range_slices_args extends TBase {
  static $_TSPEC;

  /**
   * @var ColumnParent
   */
  public $column_parent = null;
  /**
   * @var SlicePredicate
   */
  public $predicate = null;
  /**
   * @var KeyRange
   */
  public $range = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        2 => array(
          'var' => 'predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        3 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KeyRange',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_range_slices_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_get_range_slices_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_get_range_slices_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_get_range_slices_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_get_range_slices_args.predicate is unset!');
    }
    if ($this->range === null) {
      throw new TProtocolException('Required field Cassandra_get_range_slices_args.range is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_range_slices_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_get_range_slices_args.column_parent is unset!');
    }
    if ($this->predicate === null) {
      throw new TProtocolException('Required field Cassandra_get_range_slices_args.predicate is unset!');
    }
    if ($this->range === null) {
      throw new TProtocolException('Required field Cassandra_get_range_slices_args.range is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_range_slices_args.consistency_level is unset!');
    }
  }

}

class Cassandra_get_range_slices_result extends TBase {
  static $_TSPEC;

  /**
   * @var KeySlice[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\KeySlice',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_range_slices_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_range_slices_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_get_range_slices_result', self::$_TSPEC, $output);
  }

}

class Cassandra_get_paged_slice_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $column_family = null;
  /**
   * @var KeyRange
   */
  public $range = null;
  /**
   * @var string
   */
  public $start_column = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_family',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'range',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KeyRange',
          ),
        3 => array(
          'var' => 'start_column',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_paged_slice_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_get_paged_slice_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_get_paged_slice_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->column_family === null) {
      throw new TProtocolException('Required field Cassandra_get_paged_slice_args.column_family is unset!');
    }
    if ($this->range === null) {
      throw new TProtocolException('Required field Cassandra_get_paged_slice_args.range is unset!');
    }
    if ($this->start_column === null) {
      throw new TProtocolException('Required field Cassandra_get_paged_slice_args.start_column is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_paged_slice_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->column_family === null) {
      throw new TProtocolException('Required field Cassandra_get_paged_slice_args.column_family is unset!');
    }
    if ($this->range === null) {
      throw new TProtocolException('Required field Cassandra_get_paged_slice_args.range is unset!');
    }
    if ($this->start_column === null) {
      throw new TProtocolException('Required field Cassandra_get_paged_slice_args.start_column is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_paged_slice_args.consistency_level is unset!');
    }
  }

}

class Cassandra_get_paged_slice_result extends TBase {
  static $_TSPEC;

  /**
   * @var KeySlice[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\KeySlice',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_paged_slice_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_paged_slice_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_get_paged_slice_result', self::$_TSPEC, $output);
  }

}

class Cassandra_get_indexed_slices_args extends TBase {
  static $_TSPEC;

  /**
   * @var ColumnParent
   */
  public $column_parent = null;
  /**
   * @var IndexClause
   */
  public $index_clause = null;
  /**
   * @var SlicePredicate
   */
  public $column_predicate = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        2 => array(
          'var' => 'index_clause',
          'type' => TType::STRUCT,
          'class' => '\cassandra\IndexClause',
          ),
        3 => array(
          'var' => 'column_predicate',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SlicePredicate',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_indexed_slices_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_get_indexed_slices_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_get_indexed_slices_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_get_indexed_slices_args.column_parent is unset!');
    }
    if ($this->index_clause === null) {
      throw new TProtocolException('Required field Cassandra_get_indexed_slices_args.index_clause is unset!');
    }
    if ($this->column_predicate === null) {
      throw new TProtocolException('Required field Cassandra_get_indexed_slices_args.column_predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_indexed_slices_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_get_indexed_slices_args.column_parent is unset!');
    }
    if ($this->index_clause === null) {
      throw new TProtocolException('Required field Cassandra_get_indexed_slices_args.index_clause is unset!');
    }
    if ($this->column_predicate === null) {
      throw new TProtocolException('Required field Cassandra_get_indexed_slices_args.column_predicate is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_get_indexed_slices_args.consistency_level is unset!');
    }
  }

}

class Cassandra_get_indexed_slices_result extends TBase {
  static $_TSPEC;

  /**
   * @var KeySlice[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\KeySlice',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_indexed_slices_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_indexed_slices_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_get_indexed_slices_result', self::$_TSPEC, $output);
  }

}

class Cassandra_insert_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var ColumnParent
   */
  public $column_parent = null;
  /**
   * @var Column
   */
  public $column = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRUCT,
          'class' => '\cassandra\Column',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_insert_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_insert_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_insert_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_insert_args.key is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_insert_args.column_parent is unset!');
    }
    if ($this->column === null) {
      throw new TProtocolException('Required field Cassandra_insert_args.column is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_insert_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_insert_args.key is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_insert_args.column_parent is unset!');
    }
    if ($this->column === null) {
      throw new TProtocolException('Required field Cassandra_insert_args.column is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_insert_args.consistency_level is unset!');
    }
  }

}

class Cassandra_insert_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_insert_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_insert_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_insert_result', self::$_TSPEC, $output);
  }

}

class Cassandra_add_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var ColumnParent
   */
  public $column_parent = null;
  /**
   * @var CounterColumn
   */
  public $column = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_parent',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnParent',
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CounterColumn',
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_add_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_add_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_add_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_add_args.key is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_add_args.column_parent is unset!');
    }
    if ($this->column === null) {
      throw new TProtocolException('Required field Cassandra_add_args.column is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_add_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_add_args.key is unset!');
    }
    if ($this->column_parent === null) {
      throw new TProtocolException('Required field Cassandra_add_args.column_parent is unset!');
    }
    if ($this->column === null) {
      throw new TProtocolException('Required field Cassandra_add_args.column is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_add_args.consistency_level is unset!');
    }
  }

}

class Cassandra_add_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_add_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_add_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_add_result', self::$_TSPEC, $output);
  }

}

class Cassandra_cas_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var string
   */
  public $column_family = null;
  /**
   * @var Column[]
   */
  public $expected = null;
  /**
   * @var Column[]
   */
  public $updates = null;
  /**
   * @var int
   */
  public $serial_consistency_level =   9;
  /**
   * @var int
   */
  public $commit_consistency_level =   2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_family',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'expected',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\Column',
            ),
          ),
        4 => array(
          'var' => 'updates',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\Column',
            ),
          ),
        5 => array(
          'var' => 'serial_consistency_level',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'commit_consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_cas_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_cas_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_cas_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.key is unset!');
    }
    if ($this->column_family === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.column_family is unset!');
    }
    if ($this->serial_consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.serial_consistency_level is unset!');
    }
    if ($this->commit_consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.commit_consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.key is unset!');
    }
    if ($this->column_family === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.column_family is unset!');
    }
    if ($this->expected === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.expected is unset!');
    }
    if ($this->updates === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.updates is unset!');
    }
    if ($this->serial_consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.serial_consistency_level is unset!');
    }
    if ($this->commit_consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_cas_args.commit_consistency_level is unset!');
    }
  }

}

class Cassandra_cas_result extends TBase {
  static $_TSPEC;

  /**
   * @var CASResult
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CASResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_cas_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_cas_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_cas_result', self::$_TSPEC, $output);
  }

}

class Cassandra_remove_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var ColumnPath
   */
  public $column_path = null;
  /**
   * @var int
   */
  public $timestamp = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'column_path',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnPath',
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_remove_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_remove_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_remove_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_remove_args.key is unset!');
    }
    if ($this->column_path === null) {
      throw new TProtocolException('Required field Cassandra_remove_args.column_path is unset!');
    }
    if ($this->timestamp === null) {
      throw new TProtocolException('Required field Cassandra_remove_args.timestamp is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_remove_args.key is unset!');
    }
    if ($this->column_path === null) {
      throw new TProtocolException('Required field Cassandra_remove_args.column_path is unset!');
    }
    if ($this->timestamp === null) {
      throw new TProtocolException('Required field Cassandra_remove_args.timestamp is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_remove_args.consistency_level is unset!');
    }
  }

}

class Cassandra_remove_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_remove_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_remove_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_remove_result', self::$_TSPEC, $output);
  }

}

class Cassandra_remove_counter_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var ColumnPath
   */
  public $path = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'path',
          'type' => TType::STRUCT,
          'class' => '\cassandra\ColumnPath',
          ),
        3 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_remove_counter_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_remove_counter_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_remove_counter_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_remove_counter_args.key is unset!');
    }
    if ($this->path === null) {
      throw new TProtocolException('Required field Cassandra_remove_counter_args.path is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_remove_counter_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->key === null) {
      throw new TProtocolException('Required field Cassandra_remove_counter_args.key is unset!');
    }
    if ($this->path === null) {
      throw new TProtocolException('Required field Cassandra_remove_counter_args.path is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_remove_counter_args.consistency_level is unset!');
    }
  }

}

class Cassandra_remove_counter_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_remove_counter_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_remove_counter_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_remove_counter_result', self::$_TSPEC, $output);
  }

}

class Cassandra_batch_mutate_args extends TBase {
  static $_TSPEC;

  /**
   * @var array
   */
  public $mutation_map = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'mutation_map',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::LST,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::LST,
              'etype' => TType::STRUCT,
              'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\cassandra\Mutation',
                ),
              ),
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_batch_mutate_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_batch_mutate_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_batch_mutate_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->mutation_map === null) {
      throw new TProtocolException('Required field Cassandra_batch_mutate_args.mutation_map is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_batch_mutate_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->mutation_map === null) {
      throw new TProtocolException('Required field Cassandra_batch_mutate_args.mutation_map is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_batch_mutate_args.consistency_level is unset!');
    }
  }

}

class Cassandra_batch_mutate_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_batch_mutate_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_batch_mutate_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_batch_mutate_result', self::$_TSPEC, $output);
  }

}

class Cassandra_atomic_batch_mutate_args extends TBase {
  static $_TSPEC;

  /**
   * @var array
   */
  public $mutation_map = null;
  /**
   * @var int
   */
  public $consistency_level =   1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'mutation_map',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::LST,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::LST,
              'etype' => TType::STRUCT,
              'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\cassandra\Mutation',
                ),
              ),
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_atomic_batch_mutate_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_atomic_batch_mutate_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_atomic_batch_mutate_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->mutation_map === null) {
      throw new TProtocolException('Required field Cassandra_atomic_batch_mutate_args.mutation_map is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_atomic_batch_mutate_args.consistency_level is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->mutation_map === null) {
      throw new TProtocolException('Required field Cassandra_atomic_batch_mutate_args.mutation_map is unset!');
    }
    if ($this->consistency_level === null) {
      throw new TProtocolException('Required field Cassandra_atomic_batch_mutate_args.consistency_level is unset!');
    }
  }

}

class Cassandra_atomic_batch_mutate_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_atomic_batch_mutate_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_atomic_batch_mutate_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_atomic_batch_mutate_result', self::$_TSPEC, $output);
  }

}

class Cassandra_truncate_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $cfname = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cfname',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_truncate_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_truncate_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_truncate_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->cfname === null) {
      throw new TProtocolException('Required field Cassandra_truncate_args.cfname is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->cfname === null) {
      throw new TProtocolException('Required field Cassandra_truncate_args.cfname is unset!');
    }
  }

}

class Cassandra_truncate_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_truncate_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_truncate_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_truncate_result', self::$_TSPEC, $output);
  }

}

class Cassandra_get_multi_slice_args extends TBase {
  static $_TSPEC;

  /**
   * @var MultiSliceRequest
   */
  public $request = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'request',
          'type' => TType::STRUCT,
          'class' => '\cassandra\MultiSliceRequest',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_multi_slice_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_get_multi_slice_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_get_multi_slice_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->request === null) {
      throw new TProtocolException('Required field Cassandra_get_multi_slice_args.request is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->request === null) {
      throw new TProtocolException('Required field Cassandra_get_multi_slice_args.request is unset!');
    }
  }

}

class Cassandra_get_multi_slice_result extends TBase {
  static $_TSPEC;

  /**
   * @var ColumnOrSuperColumn[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\ColumnOrSuperColumn',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_get_multi_slice_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_get_multi_slice_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_get_multi_slice_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_schema_versions_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_schema_versions_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_schema_versions_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_schema_versions_args', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_schema_versions_result extends TBase {
  static $_TSPEC;

  /**
   * @var array
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_schema_versions_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_schema_versions_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_schema_versions_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_keyspaces_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspaces_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_keyspaces_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_keyspaces_args', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_keyspaces_result extends TBase {
  static $_TSPEC;

  /**
   * @var KsDef[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\KsDef',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspaces_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_keyspaces_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_keyspaces_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_cluster_name_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_cluster_name_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_cluster_name_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_cluster_name_args', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_cluster_name_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_cluster_name_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_cluster_name_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_cluster_name_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_version_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_version_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_version_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_version_args', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_version_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_version_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_version_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_version_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_ring_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_ring_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_describe_ring_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_describe_ring_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_describe_ring_args.keyspace is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_describe_ring_args.keyspace is unset!');
    }
  }

}

class Cassandra_describe_ring_result extends TBase {
  static $_TSPEC;

  /**
   * @var TokenRange[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\TokenRange',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_ring_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_ring_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_ring_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_local_ring_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_local_ring_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_describe_local_ring_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_describe_local_ring_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_describe_local_ring_args.keyspace is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_describe_local_ring_args.keyspace is unset!');
    }
  }

}

class Cassandra_describe_local_ring_result extends TBase {
  static $_TSPEC;

  /**
   * @var TokenRange[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\TokenRange',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_local_ring_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_local_ring_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_local_ring_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_token_map_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_token_map_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_token_map_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_token_map_args', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_token_map_result extends TBase {
  static $_TSPEC;

  /**
   * @var array
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_token_map_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_token_map_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_token_map_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_partitioner_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_partitioner_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_partitioner_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_partitioner_args', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_partitioner_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_partitioner_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_partitioner_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_partitioner_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_snitch_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_describe_snitch_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_snitch_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_snitch_args', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_snitch_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_snitch_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_snitch_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_snitch_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_keyspace_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspace_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_describe_keyspace_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_describe_keyspace_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_describe_keyspace_args.keyspace is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_describe_keyspace_args.keyspace is unset!');
    }
  }

}

class Cassandra_describe_keyspace_result extends TBase {
  static $_TSPEC;

  /**
   * @var KsDef
   */
  public $success = null;
  /**
   * @var NotFoundException
   */
  public $nfe = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KsDef',
          ),
        1 => array(
          'var' => 'nfe',
          'type' => TType::STRUCT,
          'class' => '\cassandra\NotFoundException',
          ),
        2 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_keyspace_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_keyspace_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_splits_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $cfName = null;
  /**
   * @var string
   */
  public $start_token = null;
  /**
   * @var string
   */
  public $end_token = null;
  /**
   * @var int
   */
  public $keys_per_split = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cfName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'start_token',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'end_token',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'keys_per_split',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_describe_splits_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_describe_splits_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->cfName === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_args.cfName is unset!');
    }
    if ($this->start_token === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_args.start_token is unset!');
    }
    if ($this->end_token === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_args.end_token is unset!');
    }
    if ($this->keys_per_split === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_args.keys_per_split is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->cfName === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_args.cfName is unset!');
    }
    if ($this->start_token === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_args.start_token is unset!');
    }
    if ($this->end_token === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_args.end_token is unset!');
    }
    if ($this->keys_per_split === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_args.keys_per_split is unset!');
    }
  }

}

class Cassandra_describe_splits_result extends TBase {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_splits_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_splits_result', self::$_TSPEC, $output);
  }

}

class Cassandra_trace_next_query_args extends TBase {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Cassandra_trace_next_query_args';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_trace_next_query_args', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_trace_next_query_args', self::$_TSPEC, $output);
  }

}

class Cassandra_trace_next_query_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_trace_next_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_trace_next_query_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_trace_next_query_result', self::$_TSPEC, $output);
  }

}

class Cassandra_describe_splits_ex_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $cfName = null;
  /**
   * @var string
   */
  public $start_token = null;
  /**
   * @var string
   */
  public $end_token = null;
  /**
   * @var int
   */
  public $keys_per_split = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cfName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'start_token',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'end_token',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'keys_per_split',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_ex_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_describe_splits_ex_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_describe_splits_ex_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->cfName === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_ex_args.cfName is unset!');
    }
    if ($this->start_token === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_ex_args.start_token is unset!');
    }
    if ($this->end_token === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_ex_args.end_token is unset!');
    }
    if ($this->keys_per_split === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_ex_args.keys_per_split is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->cfName === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_ex_args.cfName is unset!');
    }
    if ($this->start_token === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_ex_args.start_token is unset!');
    }
    if ($this->end_token === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_ex_args.end_token is unset!');
    }
    if ($this->keys_per_split === null) {
      throw new TProtocolException('Required field Cassandra_describe_splits_ex_args.keys_per_split is unset!');
    }
  }

}

class Cassandra_describe_splits_ex_result extends TBase {
  static $_TSPEC;

  /**
   * @var CfSplit[]
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\cassandra\CfSplit',
            ),
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_describe_splits_ex_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_describe_splits_ex_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_describe_splits_ex_result', self::$_TSPEC, $output);
  }

}

class Cassandra_system_add_column_family_args extends TBase {
  static $_TSPEC;

  /**
   * @var CfDef
   */
  public $cf_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cf_def',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CfDef',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_add_column_family_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_system_add_column_family_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_system_add_column_family_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->cf_def === null) {
      throw new TProtocolException('Required field Cassandra_system_add_column_family_args.cf_def is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->cf_def === null) {
      throw new TProtocolException('Required field Cassandra_system_add_column_family_args.cf_def is unset!');
    }
  }

}

class Cassandra_system_add_column_family_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_add_column_family_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_add_column_family_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_system_add_column_family_result', self::$_TSPEC, $output);
  }

}

class Cassandra_system_drop_column_family_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $column_family = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'column_family',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_column_family_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_system_drop_column_family_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_system_drop_column_family_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->column_family === null) {
      throw new TProtocolException('Required field Cassandra_system_drop_column_family_args.column_family is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->column_family === null) {
      throw new TProtocolException('Required field Cassandra_system_drop_column_family_args.column_family is unset!');
    }
  }

}

class Cassandra_system_drop_column_family_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_column_family_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_drop_column_family_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_system_drop_column_family_result', self::$_TSPEC, $output);
  }

}

class Cassandra_system_add_keyspace_args extends TBase {
  static $_TSPEC;

  /**
   * @var KsDef
   */
  public $ks_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ks_def',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KsDef',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_add_keyspace_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_system_add_keyspace_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_system_add_keyspace_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->ks_def === null) {
      throw new TProtocolException('Required field Cassandra_system_add_keyspace_args.ks_def is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->ks_def === null) {
      throw new TProtocolException('Required field Cassandra_system_add_keyspace_args.ks_def is unset!');
    }
  }

}

class Cassandra_system_add_keyspace_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_add_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_add_keyspace_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_system_add_keyspace_result', self::$_TSPEC, $output);
  }

}

class Cassandra_system_drop_keyspace_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $keyspace = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keyspace',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_keyspace_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_system_drop_keyspace_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_system_drop_keyspace_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_system_drop_keyspace_args.keyspace is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->keyspace === null) {
      throw new TProtocolException('Required field Cassandra_system_drop_keyspace_args.keyspace is unset!');
    }
  }

}

class Cassandra_system_drop_keyspace_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_drop_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_drop_keyspace_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_system_drop_keyspace_result', self::$_TSPEC, $output);
  }

}

class Cassandra_system_update_keyspace_args extends TBase {
  static $_TSPEC;

  /**
   * @var KsDef
   */
  public $ks_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ks_def',
          'type' => TType::STRUCT,
          'class' => '\cassandra\KsDef',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_update_keyspace_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_system_update_keyspace_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_system_update_keyspace_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->ks_def === null) {
      throw new TProtocolException('Required field Cassandra_system_update_keyspace_args.ks_def is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->ks_def === null) {
      throw new TProtocolException('Required field Cassandra_system_update_keyspace_args.ks_def is unset!');
    }
  }

}

class Cassandra_system_update_keyspace_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_update_keyspace_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_update_keyspace_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_system_update_keyspace_result', self::$_TSPEC, $output);
  }

}

class Cassandra_system_update_column_family_args extends TBase {
  static $_TSPEC;

  /**
   * @var CfDef
   */
  public $cf_def = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cf_def',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CfDef',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_update_column_family_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_system_update_column_family_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_system_update_column_family_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->cf_def === null) {
      throw new TProtocolException('Required field Cassandra_system_update_column_family_args.cf_def is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->cf_def === null) {
      throw new TProtocolException('Required field Cassandra_system_update_column_family_args.cf_def is unset!');
    }
  }

}

class Cassandra_system_update_column_family_result extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_system_update_column_family_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_system_update_column_family_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_system_update_column_family_result', self::$_TSPEC, $output);
  }

}

class Cassandra_execute_cql_query_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $query = null;
  /**
   * @var int
   */
  public $compression = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql_query_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_execute_cql_query_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_execute_cql_query_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->query === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql_query_args.query is unset!');
    }
    if ($this->compression === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql_query_args.compression is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->query === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql_query_args.query is unset!');
    }
    if ($this->compression === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql_query_args.compression is unset!');
    }
  }

}

class Cassandra_execute_cql_query_result extends TBase {
  static $_TSPEC;

  /**
   * @var CqlResult
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_cql_query_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_execute_cql_query_result', self::$_TSPEC, $output);
  }

}

class Cassandra_execute_cql3_query_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $query = null;
  /**
   * @var int
   */
  public $compression = null;
  /**
   * @var int
   */
  public $consistency = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'consistency',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql3_query_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_execute_cql3_query_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_execute_cql3_query_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->query === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql3_query_args.query is unset!');
    }
    if ($this->compression === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql3_query_args.compression is unset!');
    }
    if ($this->consistency === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql3_query_args.consistency is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->query === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql3_query_args.query is unset!');
    }
    if ($this->compression === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql3_query_args.compression is unset!');
    }
    if ($this->consistency === null) {
      throw new TProtocolException('Required field Cassandra_execute_cql3_query_args.consistency is unset!');
    }
  }

}

class Cassandra_execute_cql3_query_result extends TBase {
  static $_TSPEC;

  /**
   * @var CqlResult
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_cql3_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_cql3_query_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_execute_cql3_query_result', self::$_TSPEC, $output);
  }

}

class Cassandra_prepare_cql_query_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $query = null;
  /**
   * @var int
   */
  public $compression = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_prepare_cql_query_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_prepare_cql_query_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_prepare_cql_query_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->query === null) {
      throw new TProtocolException('Required field Cassandra_prepare_cql_query_args.query is unset!');
    }
    if ($this->compression === null) {
      throw new TProtocolException('Required field Cassandra_prepare_cql_query_args.compression is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->query === null) {
      throw new TProtocolException('Required field Cassandra_prepare_cql_query_args.query is unset!');
    }
    if ($this->compression === null) {
      throw new TProtocolException('Required field Cassandra_prepare_cql_query_args.compression is unset!');
    }
  }

}

class Cassandra_prepare_cql_query_result extends TBase {
  static $_TSPEC;

  /**
   * @var CqlPreparedResult
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlPreparedResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_prepare_cql_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_prepare_cql_query_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_prepare_cql_query_result', self::$_TSPEC, $output);
  }

}

class Cassandra_prepare_cql3_query_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $query = null;
  /**
   * @var int
   */
  public $compression = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'query',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'compression',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_prepare_cql3_query_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_prepare_cql3_query_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_prepare_cql3_query_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->query === null) {
      throw new TProtocolException('Required field Cassandra_prepare_cql3_query_args.query is unset!');
    }
    if ($this->compression === null) {
      throw new TProtocolException('Required field Cassandra_prepare_cql3_query_args.compression is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->query === null) {
      throw new TProtocolException('Required field Cassandra_prepare_cql3_query_args.query is unset!');
    }
    if ($this->compression === null) {
      throw new TProtocolException('Required field Cassandra_prepare_cql3_query_args.compression is unset!');
    }
  }

}

class Cassandra_prepare_cql3_query_result extends TBase {
  static $_TSPEC;

  /**
   * @var CqlPreparedResult
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlPreparedResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_prepare_cql3_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_prepare_cql3_query_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_prepare_cql3_query_result', self::$_TSPEC, $output);
  }

}

class Cassandra_execute_prepared_cql_query_args extends TBase {
  static $_TSPEC;

  /**
   * @var int
   */
  public $itemId = null;
  /**
   * @var string[]
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'itemId',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_prepared_cql_query_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_execute_prepared_cql_query_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_execute_prepared_cql_query_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->itemId === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql_query_args.itemId is unset!');
    }
    if ($this->values === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql_query_args.values is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->itemId === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql_query_args.itemId is unset!');
    }
    if ($this->values === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql_query_args.values is unset!');
    }
  }

}

class Cassandra_execute_prepared_cql_query_result extends TBase {
  static $_TSPEC;

  /**
   * @var CqlResult
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_prepared_cql_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_prepared_cql_query_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_execute_prepared_cql_query_result', self::$_TSPEC, $output);
  }

}

class Cassandra_execute_prepared_cql3_query_args extends TBase {
  static $_TSPEC;

  /**
   * @var int
   */
  public $itemId = null;
  /**
   * @var string[]
   */
  public $values = null;
  /**
   * @var int
   */
  public $consistency = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'itemId',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'consistency',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_prepared_cql3_query_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_execute_prepared_cql3_query_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_execute_prepared_cql3_query_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->itemId === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql3_query_args.itemId is unset!');
    }
    if ($this->values === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql3_query_args.values is unset!');
    }
    if ($this->consistency === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql3_query_args.consistency is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->itemId === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql3_query_args.itemId is unset!');
    }
    if ($this->values === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql3_query_args.values is unset!');
    }
    if ($this->consistency === null) {
      throw new TProtocolException('Required field Cassandra_execute_prepared_cql3_query_args.consistency is unset!');
    }
  }

}

class Cassandra_execute_prepared_cql3_query_result extends TBase {
  static $_TSPEC;

  /**
   * @var CqlResult
   */
  public $success = null;
  /**
   * @var InvalidRequestException
   */
  public $ire = null;
  /**
   * @var UnavailableException
   */
  public $ue = null;
  /**
   * @var TimedOutException
   */
  public $te = null;
  /**
   * @var SchemaDisagreementException
   */
  public $sde = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\cassandra\CqlResult',
          ),
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        2 => array(
          'var' => 'ue',
          'type' => TType::STRUCT,
          'class' => '\cassandra\UnavailableException',
          ),
        3 => array(
          'var' => 'te',
          'type' => TType::STRUCT,
          'class' => '\cassandra\TimedOutException',
          ),
        4 => array(
          'var' => 'sde',
          'type' => TType::STRUCT,
          'class' => '\cassandra\SchemaDisagreementException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_execute_prepared_cql3_query_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_execute_prepared_cql3_query_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_execute_prepared_cql3_query_result', self::$_TSPEC, $output);
  }

}

class Cassandra_set_cql_version_args extends TBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $version = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'version',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_set_cql_version_args';
  }

  public function read($input)
  {
    $tmp = $this->_read('Cassandra_set_cql_version_args', self::$_TSPEC, $input);
    $this->_validateForRead();
    return $tmp;
  }

  public function write($output) {
    $this->_validateForWrite();
    return $this->_write('Cassandra_set_cql_version_args', self::$_TSPEC, $output);
  }

  private function _validateForRead() {
    if ($this->version === null) {
      throw new TProtocolException('Required field Cassandra_set_cql_version_args.version is unset!');
    }
  }

  private function _validateForWrite() {
    if ($this->version === null) {
      throw new TProtocolException('Required field Cassandra_set_cql_version_args.version is unset!');
    }
  }

}

class Cassandra_set_cql_version_result extends TBase {
  static $_TSPEC;

  /**
   * @var InvalidRequestException
   */
  public $ire = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ire',
          'type' => TType::STRUCT,
          'class' => '\cassandra\InvalidRequestException',
          ),
        );
    }
    if (is_array($vals)) {
      parent::__construct(self::$_TSPEC, $vals);
    }
  }

  public function getName() {
    return 'Cassandra_set_cql_version_result';
  }

  public function read($input)
  {
    return $this->_read('Cassandra_set_cql_version_result', self::$_TSPEC, $input);
  }

  public function write($output) {
    return $this->_write('Cassandra_set_cql_version_result', self::$_TSPEC, $output);
  }

}


