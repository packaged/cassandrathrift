<?php
namespace cassandra;

/**
 * Autogenerated by Thrift Compiler (0.15.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;

/**
 * A slice range is a structure that stores basic range, ordering and limit information for a query that will return
 * multiple columns. It could be thought of as Cassandra's version of LIMIT and ORDER BY
 * 
 * @param start. The column name to start the slice with. This attribute is not required, though there is no default value,
 *               and can be safely set to '', i.e., an empty byte array, to start with the first column name. Otherwise, it
 *               must a valid value under the rules of the Comparator defined for the given ColumnFamily.
 * @param finish. The column name to stop the slice at. This attribute is not required, though there is no default value,
 *                and can be safely set to an empty byte array to not stop until 'count' results are seen. Otherwise, it
 *                must also be a valid value to the ColumnFamily Comparator.
 * @param reversed. Whether the results should be ordered in reversed order. Similar to ORDER BY blah DESC in SQL.
 * @param count. How many columns to return. Similar to LIMIT in SQL. May be arbitrarily large, but Thrift will
 *               materialize the whole result into memory before returning it to the client, so be aware that you may
 *               be better served by iterating through slices by passing the last value of one call in as the 'start'
 *               of the next instead of increasing 'count' arbitrarily large.
 */
class SliceRange extends TBase
{
    static public $isValidate = true;

    static public $_TSPEC = array(
        1 => array(
            'var' => 'start',
            'isRequired' => true,
            'type' => TType::STRING,
        ),
        2 => array(
            'var' => 'finish',
            'isRequired' => true,
            'type' => TType::STRING,
        ),
        3 => array(
            'var' => 'reversed',
            'isRequired' => true,
            'type' => TType::BOOL,
        ),
        4 => array(
            'var' => 'count',
            'isRequired' => true,
            'type' => TType::I32,
        ),
    );

    /**
     * @var string
     */
    public $start = null;
    /**
     * @var string
     */
    public $finish = null;
    /**
     * @var bool
     */
    public $reversed = false;
    /**
     * @var int
     */
    public $count = 100;

    public function __construct($vals = null)
    {
        if (is_array($vals)) {
            parent::__construct(self::$_TSPEC, $vals);
        }
    }

    public function getName()
    {
        return 'SliceRange';
    }


    public function read($input)
    {
        $tmp = $this->_read('SliceRange', self::$_TSPEC, $input);
        $this->_validateForRead();
        return $tmp;
    }


    public function write($output)
    {
        $this->_validateForWrite();
        return $this->_write('SliceRange', self::$_TSPEC, $output);
    }


    private function _validateForRead() {
        if ($this->start === null) {
            throw new TProtocolException('Required field SliceRange.start is unset!');
        }
        if ($this->finish === null) {
            throw new TProtocolException('Required field SliceRange.finish is unset!');
        }
        if ($this->reversed === null) {
            throw new TProtocolException('Required field SliceRange.reversed is unset!');
        }
        if ($this->count === null) {
            throw new TProtocolException('Required field SliceRange.count is unset!');
        }
    }

    private function _validateForWrite() {
        if ($this->start === null) {
            throw new TProtocolException('Required field SliceRange.start is unset!');
        }
        if ($this->finish === null) {
            throw new TProtocolException('Required field SliceRange.finish is unset!');
        }
        if ($this->reversed === null) {
            throw new TProtocolException('Required field SliceRange.reversed is unset!');
        }
        if ($this->count === null) {
            throw new TProtocolException('Required field SliceRange.count is unset!');
        }
    }
}
